# chatgpt 5.3 codex 
## v1
````
### 🔍 分析プロセス（思考プロセス）
このModは「外部JSON（半信頼入力）を読み込み、ゲームのローカライズ辞書に注入し、同時に抽出ファイルを書き出す」I/O集中型の中核コンポーネントです。  
リスクの匂いは、入力境界（設定値/JSONサイズ/JSON構造）、イベント駆動処理の再入、抽出処理の実行頻度、そして例外時の観測性に集中していました。  
DBは未使用なのでDBA観点は「クエリ最適化」ではなく「大量データ処理・一貫性・競合」の同型問題として評価しています。

### 🚨 優先度: Critical / High (セキュリティ・バグ・パフォーマンスの重大欠陥)
- **設定値 `localesFolder` によるパストラバーサル（A:セキュリティ）**  
  - **Why (なぜ問題か/どのようなリスクがあるか)**: Mod.cs と Mod.cs で `Path.Combine` をそのまま使っており、`..\` を含む設定でMod配下外を読み書き可能です。ユーザー権限内とはいえ、任意ファイル探索/上書きの踏み台になります。  
  - **How (どう直すべきか)**: 正規化した絶対パスがModルート配下かを検証し、逸脱時は `"Locales"` に強制フォールバック。  

- **巨大/悪性JSONでメモリ枯渇し得る（A/D:耐障害性・計算資源）**  
  - **Why**: LocaleLoader.cs の `File.ReadAllText` は無制限読込です。複数巨大ファイルで `O(total bytes)` を一気に確保し、起動時DoSになります。  
  - **How**: ファイルサイズ上限（例: 5MB）を導入し、`StreamReader` + `JsonTextReader` でストリーミングデシリアライズ。  

- **不正JSON構造で注入処理が一括失敗（D:境界値バグ）**  
  - **Why**: LocaleInjector.cs で `entry.Value` null を想定しておらず、1件壊れたエントリで `NullReferenceException` が発生し、全体注入が止まります。  
  - **How**: キー空/null、値nullを個別スキップし、健全エントリだけ継続処理。  

- **イベント再入時の競合 + 高頻度抽出I/O（B/D:一貫性・高負荷劣化）**  
  - **Why**: Mod.cs → Mod.cs でイベント都度抽出、かつ `_hasInjected` は非同期安全でなく再入競合余地があります（重複注入・過剰I/O）。  
  - **How**: `Interlocked` で注入を単一実行化し、抽出はロケール単位で1回に抑制（または最短間隔スロットリング）。  

### ⚠️ 優先度: Medium (アーキテクチャの整合性・保守性・設計の改善)
- **翻訳ファイル読込順の非決定性（D/A）**  
  - **Why**: LocaleLoader.cs と LocaleLoader.cs の `GetFiles` 結果順が未固定で、LocaleInjector.cs で後勝ち上書きが実行環境依存。再現性が落ちます。  
  - **How / 提案**: ファイル名でソートし、競合キーは警告ログを出して優先規則（例: `Extracted` < 手動 `*_ja.json`）を固定化。

- **反射依存の脆さ（C）**  
  - **Why**: LocaleExtractor.cs 以降で内部フィールド名に強依存し、ゲーム更新で静かに劣化しやすい。  
  - **How / 提案**: 反射アクセスを専用アダプタ層に隔離し、起動時セルフチェック（期待フィールド有無）とバージョン警告を追加。

- **例外の可観測性不足（C）**  
  - **Why**: ModLogger.cs は `ex.Message` のみでスタック喪失。障害解析コストが長期的に高い。  
  - **How / 提案**: `ex.ToString()` を出力し、I/O系はファイル名・サイズ・処理フェーズを構造化ログで残す。

### 💡 優先度: Low (よりモダンな書き方・軽微な最適化)
- `File.WriteAllText`/`ReadAllText` はエンコーディング明示（UTF-8）に統一すると環境差異を減らせます。  
- `targetLocale` は空白文字列を `"ja-JP"` に正規化すると設定ミス耐性が上がります。  
- 大量キー処理時は `Dictionary` 初期容量を見積もって再ハッシュ回数を減らせます。

### 🛡️ 良かった点 (Good Practices)
- 失敗時フォールバック（ソース抽出→一括抽出）があり、機能停止しにくい設計です（LocaleExtractor.cs）。  
- `OnDispose` でイベント解除とソース除去を実施しており、ライフサイクル管理の意識が高いです（Mod.cs）。  
- 既存翻訳保持マージは翻訳作業の継続性に有効で、実運用上のUXを損ねにくい実装です（LocaleExtractor.cs）。

````

## v2
````
### 🔍 分析プロセス（思考プロセス）
本コードは「ローカライズ読込」「ゲームへの注入」「キー抽出」の3責務で構成され、実質的な外部入力境界は JSON ファイルI/O とゲーム内部オブジェクト（Reflection経由）です。  
リスクの匂いは、再読み込み時の `MemorySource` 管理、無制限ファイル走査、長大な抽出ロジックの例外握りつぶしに集中していました。  
DBアクセスは存在しないため DBA観点は「I/O・メモリ・計算量」を中心に評価しています。

### 🚨 優先度: Critical / High (セキュリティ・バグ・パフォーマンスの重大欠陥)
- **再読み込みで `MemorySource` が累積し続ける（メモリ/性能劣化）**
  - **Why (なぜ問題か/どのようなリスクがあるか)**: LocalizationInjector.cs, LocalizationInjector.cs で毎回 `AddSource` する一方、LocalizationInjector.cs は追跡リストを消すだけで `LocalizationManager` からは未削除です。手動再読込やロケール変更で注入回数が増えるほど辞書検索コスト・メモリ使用量が単調増加し、長時間プレイ時に劣化します。
  - **How (どう直すべきか)**: `AddSource` した参照を保持し、再読み込み前に `RemoveSource` 相当APIで実体を除去。APIが無い場合は「同一キー空間の単一ソースを差し替える」設計に変更し、`Setting.RegisterLocalization()` の再注入も冪等化してください（TranslationLoaderSystem.cs, Setting.cs）。

- **翻訳ファイル探索/読込が無制限で DoS 耐性が弱い**
  - **Why (なぜ問題か/どのようなリスクがあるか)**: TranslationLoader.cs の再帰探索＋ TranslationLoader.cs の `ReadAllText` は、巨大ファイル・大量ファイル・ジャンクション経由の広域走査で CPU/メモリ/IO を圧迫します。ローカルModでも「悪意ある配布物」や誤配置で固まりやすいです。
  - **How (どう直すべきか)**: 最大ファイル数・最大サイズ・探索深さを設定化し、`FileInfo.Length` で事前拒否。ストリーミング読込（`JsonTextReader`）＋タイムアウト/キャンセル導入。ジャンクション/シンボリックリンクをスキップして Translations 直下または許可サブフォルダのみ対象に絞る。

- **不正JSONで `NullReferenceException` が起きやすい（可用性低下）**
  - **Why (なぜ問題か/どのようなリスクがあるか)**: TranslationLoader.cs, TranslationLoader.cs で `entry.Value` の null を未考慮。`entries` 内に `key: null` があるだけでファイル単位で読み込み失敗し、翻訳適用率が落ちます。
  - **How (どう直すべきか)**: `entry.Value == null` を防御し、無効エントリのみスキップ。`LoadFile` 時にスキーマ検証（必須キー、型、長さ上限）を行い、エラー件数をログ集約して継続処理。

### ⚠️ 優先度: Medium (アーキテクチャの整合性・保守性・設計の改善)
- **抽出ロジックが Reflection 依存で脆く、障害解析しづらい**
  - **Why**: TranslationExtractor.cs はゲーム内部フィールド名に強く依存し、複数箇所で `catch {}` があるため、アップデート追従時に「静かに抽出精度低下」しやすいです（例: TranslationExtractor.cs, TranslationExtractor.cs）。
  - **How / 提案**: 抽出を Strategy 化（`SourceBased` / `DictionaryFallback`）し、失敗理由を構造化ログ化。`catch` は最低でも `Warn` で例外型と対象フィールド名を残し、失敗率メトリクスを持たせる。

- **`IsStandardCategory` の都度 `HashSet` 生成で無駄なアロケーション**
  - **Why**: TranslationExtractor.cs が呼び出しごとに集合を生成し、高エントリ数時にGC圧力を増やします。
  - **How / 提案**: `static readonly HashSet<string>` に昇格し再利用。ホットパスの割り当てを削減。

- **静的フラグ運用の競合耐性が弱い**
  - **Why**: TranslationLoaderSystem.cs, TranslationExtractorSystem.cs などは単純 `bool`。現状はメインスレッド前提でも、将来の並列化/イベント変更で取りこぼしや重複実行の温床になります。
  - **How / 提案**: `Interlocked.Exchange` でフラグ消費を原子的にし、将来拡張に備える。

### 💡 優先度: Low (よりモダンな書き方・軽微な最適化)
- TranslationExtractor.cs の `DateTime.Now` はローカルタイム依存なので `UtcNow` 推奨。  
- LocalizationInjector.cs の無言フォールバックは Debug 時のみでも理由ログを出すと切り分けが速い。  
- TranslationExtractor.cs の `MergeByKeyOverlap` は最悪 $O(n^2 \cdot k)$ なので、Mod数増加時は MinHash/署名比較などで事前絞り込み可能。

### 🛡️ 良かった点 (Good Practices)
- ロケール変更にデバウンスを入れており、イベント連打時の不要処理を抑制している（Mod.cs）。  
- 既訳マージ方針があり、抽出時に翻訳資産を壊しにくい設計（TranslationExtractor.cs）。  
- ログポイントが比較的多く、通常系の観測性は確保できている。

````

# claude 4.6 opus
## v1
````
全コードの精査が完了しました。以下、レビュー結果を出力します。

---

## 🔍 分析プロセス（思考プロセス）

このModは、CS2のゲーム内 `LocalizationManager` の内部構造をリフレクションで掘り下げてMod由来の翻訳キーを抽出し、JSONファイルとして書き出す「Extractor」と、ユーザーが翻訳したJSONを逆にゲームの `MemorySource` へ注入する「Loader/Injector」の二層構造。リスクの匂いを最も強く感じるのは、**(1)** 静的ミュータブル状態のスレッド安全性、**(2)** `SanitizeModId` のパストラバーサル欠陥、**(3)** 毎回インスタンス生成される `HashSet` によるGC圧迫、**(4)** `MemorySource` の無限蓄積 の4点。

---

### 🚨 優先度: Critical / High（セキュリティ・バグ・パフォーマンスの重大欠陥）

---

- **パストラバーサル: `SanitizeModId` が `..` を通過させる**
  - **Why**: TranslationExtractor.cs は `Path.GetInvalidFileNameChars()` に含まれない文字を通すが、`.`（ドット）はファイル名として有効な文字のため、`..` がそのまま通過する。抽出時にゲーム内のMod名が悪意を持って Documents のようなキーパターンを含むと、`Path.Combine(outputDirectory, modId)` → `Path.Combine(outputDirectory, "..")` となり、**翻訳ディレクトリ外への任意ファイル書き込み**が可能になる。CS2のModは第三者が作成するため、攻撃ベクトルとして現実的。
  - **How**:
    ```csharp
    private static string SanitizeModId(string modId)
    {
        if (string.IsNullOrEmpty(modId)) return null;
    
        var invalid = Path.GetInvalidFileNameChars();
        var sanitized = new string(modId.Where(c => !invalid.Contains(c)).ToArray());
    
        // パストラバーサル防止
        if (string.IsNullOrEmpty(sanitized)) return null;
        sanitized = sanitized.Trim('.');           // 先頭・末尾のドットを除去
        if (string.IsNullOrEmpty(sanitized)) return null;
        if (sanitized == "." || sanitized == "..") return null;
    
        return sanitized;
    }
    ```
    加えて `WriteModTranslationFile` 側で最終パスが `outputDirectory` 配下であることを `Path.GetFullPath` で正規化して検証する防御も追加すべき。

---

- **スレッド安全性: `long LastLocaleChangeTicks` の非アトミックR/W（net472 = 32bit CLR）**
  - **Why**: ターゲットが `net472` であるため、32bitランタイム上では `long`（8バイト）の読み書きはアトミックではない（ECMA-335 §I.12.6.6）。 Mod.cs の `LastLocaleChangeTicks` は `OnLocaleChanged`（UIスレッド/コールバック）で書き込み、TranslationLoaderSystem.cs の `OnUpdate`（ECSスレッド）で読み取る。ティアードリードにより不正な値が読まれ、デバウンスが永久に成立しない or 即座に発火するバグの温床。
  - **How**: `Interlocked.Exchange` / `Interlocked.Read` を使用するか、`volatile` ではなく明示的にロック/`Interlocked` で保護する。同じく `SuppressLocaleCallback` と `LocaleChangePending` も `volatile` 宣言が最低限必要。
    ```csharp
    private static long _lastLocaleChangeTicks = 0;
    public static long LastLocaleChangeTicks
    {
        get => Interlocked.Read(ref _lastLocaleChangeTicks);
        private set => Interlocked.Exchange(ref _lastLocaleChangeTicks, value);
    }
    ```

---

- **`IsStandardCategory` が呼び出しごとに `new HashSet<string>` を生成**
  - **Why**: TranslationExtractor.cs でローカル変数として `new HashSet<string>` を毎回生成している。この関数は `IdentifyModFromKeys` のループ内から各エントリキーに対して呼ばれ、さらにフォールバック時にも `ExtractModId` 経由で呼ばれるため、**数万〜数十万回呼ばれうる**。GC Gen0 の大量アロケーション → GC ストールを引き起こし、ゲームのフレーム落ちに直結する。
  - **How**: `VanillaPrefixes` と同様に `private static readonly HashSet<string>` にする。

---

- **`MemorySource` の無限蓄積によるメモリリーク**
  - **Why**: LocalizationInjector.cs の `Inject` / `InjectDictionary` は毎回 `new MemorySource` を `localizationManager.AddSource` するが、**既存ソースの削除は行わない**。`ClearTrackedSources` はトラッキングリストを空にするだけで、ゲーム側の `LocalizationManager` に登録されたソースは残り続ける。ロケール切り替え・手動リロード・設定画面のローカライズ注入を繰り返すたびにソースが蓄積し、ゲーム長時間プレイ時にメモリを浪食する。
  - **How**: `AddSource` の前に、前回登録したソースを `LocalizationManager` から削除する仕組みが必要。ゲームAPIに `RemoveSource` が無い場合は、1つの `MemorySource` を使い回してその内部辞書を差し替える方式に切り替える。

---

### ⚠️ 優先度: Medium（アーキテクチャの整合性・保守性・設計の改善）

---

- **TranslationExtractor.cs が1221行の God Class**
  - **Why**: Phase 1抽出、Phase 2フォールバック、グルーピング、ファイルI/O、ヘルパー群がすべて1ファイルに詰め込まれている。責務分離ができておらず、どこを変更するとどこに影響するか追跡困難。1221行のstaticクラスは、テスタビリティもゼロ。
  - **How / 提案**: 最低限以下に分割する。
    - `SourceBasedExtractor` (Phase 1: m_UserSources抽出)
    - `DictionaryBasedExtractor` (Phase 2: フォールバック)
    - `ModGrouper` (グルーピング・マージロジック)
    - `ExtractionFileWriter` (JSON出力)
    - `ReflectionHelper` (リフレクションユーティリティ)

---

- **`MergeByKeyOverlap` の推移的閉包(transitive closure)未対応**
  - **Why**: TranslationExtractor.cs で A→B の吸収が決定した後、B→C の吸収関係がある場合、C のエントリは B に吸収されるが B 自体は A に吸収されているため、C のエントリが最終結果に含まれない可能性がある。また、A が B に吸収された後に A→C の判定が `mergeTarget.ContainsKey(names[i])` で スキップされるため、C が宙に浮く。
  - **How / 提案**: Union-Find（素集合データ構造）を使って推移的な統合を正しく処理するか、while ループで `mergeTarget` が変化しなくなるまで繰り返す。

---

- **例外の「握りつぶし」が多すぎる — 障害切り分け不能**
  - **Why**: `ExtractFromUserSources` 内のソース読み取り (TranslationExtractor.cs `catch { continue; }`)、`ExtractEntriesFromObject` (TranslationExtractor.cs `catch { }`)、`TryGetFromDeepScan` (TranslationExtractor.cs `catch { /* skip */ }`) など、例外を完全に無視して `continue` / 空 `catch` が大量にある。ゲーム内のAPI変更で挙動が壊れた場合、ログに何も残らず原因調査が不可能になる。
  - **How / 提案**: 最低限 `catch (Exception ex) { Mod.Log.Warn($"...{ex.Message}"); }` レベルのデバッグログを出力する。デバッグモード時のみの条件分岐でもよい。

---

- **`ExtractionResult` のファイル配置がアーキテクチャルールに違反**
  - **Why**: `ExtractionResult` クラスが TranslationExtractor.cs に定義されているが、これはデータモデルであり `Models/` に置くべき。TranslationData.cs に `TranslationFile` / `TranslationEntry` と同居させるか、`Models/ExtractionResult.cs` として分離すべき。
  - **How / 提案**: `Models/ExtractionResult.cs` に移動。

---

- **静的フラグ `_reloadRequested` / `_extractionRequested` のクラス設計**
  - **Why**: TranslationLoaderSystem.cs と TranslationExtractorSystem.cs で static フラグをリクエスト用に使用しているが、これは本質的にグローバル状態。ECS のシステムインスタンスが再生成された場合やマルチスレッドでのフラグ競合リスクがある。
  - **How / 提案**: 最低限 `volatile` 修飾子を付与する。理想的にはインスタンスメソッドでキューイングし、Singleton パターンで参照する。

---

- **`VanillaPrefixes` の `StartsWith` 線形走査が非効率**
  - **Why**: TranslationExtractor.cs は全プレフィックスに対して `StartsWith` を行う O(P) 走査。プレフィックスは約40個あり、キーが数万件の場合 40万回の文字列比較になる。
  - **How / 提案**: プレフィックスを `.` 区切りの最初のセグメントで `HashSet` 引きに変換する。`Options.SECTION[General]` のような完全一致混在パターンは分離して処理する。

---

### 💡 優先度: Low（よりモダンな書き方・軽微な最適化）

- `Dictionary.ContainsKey` → `TryGetValue` パターンへの統一。`ExtractFromUserSources` 内に `ContainsKey` + インデクサアクセスの冗長パターンが10箇所以上ある。
- `SanitizeModId` 内の `modId.Where(...).ToArray()` は `char[]` をLINQで生成するが、`StringBuilder` の方が低アロケーション。
- `WriteModTranslationFile` 内の `DateTime.Now.ToString("yyyy-MM-dd")` は `DateTime.UtcNow` にすべき（タイムゾーン依存の回避）。
- `TranslationLoader.LoadFile` の `File.ReadAllText` は大きなファイルでLOH（Large Object Heap）に乗る可能性がある。`StreamReader` + `JsonSerializer.Deserialize(StreamReader)` の方がメモリ効率が良い。
- `GetLocalePriority` の `locale.ToLowerInvariant()` は新しい文字列を毎回アロケートする。`string.Equals(..., OrdinalIgnoreCase)` と `StartsWith(..., OrdinalIgnoreCase)` で十分。
- `LogManagerInternals` のリフレクション走査は `EnableDebugLog` ガードの外にある `try/catch` が広すぎる。プロパティ読み出しで副作用を持つゲッターがあった場合にゲーム状態を壊すリスクがある。
- Mod.cs の `Log` を `public static readonly` で公開しているが、`internal` で十分。外部DLLからの意図しないログ注入を防げる。

---

### 🛡️ 良かった点 (Good Practices)

- **デバウンスパターンの採用**: ロケール変更イベントの連射を抑制する `LastLocaleChangeTicks` + `DebounceSeconds` の設計は、ゲームMod特有の再帰呼び出し問題を正しく認識しており、`SuppressLocaleCallback` との二重防御も適切。
- **フォールバック戦略（Phase 1 → Phase 2）**: ソースベース抽出が失敗した場合に辞書ベースにフォールバックする多段戦略で、ゲームAPIの内部構造変更への耐性が高い。
- **既存翻訳の保持マージ**: `WriteModTranslationFile` で既存ファイルの `translation` 値を保持して再マージする設計は、ユーザーの翻訳作業を無駄にしない優れた配慮。
- **Newtonsoft.Json の `TypeNameHandling` がデフォルト（None）**: 外部JSONのデシリアライゼーションで型情報を使わないため、デシリアライズ攻撃(CVE-2021-27293 等)のリスクがない。
- **`OnDispose` でのイベント解除**: コールバック `onActiveDictionaryChanged -= OnLocaleChanged` を確実に解除しており、Modアンロード時のイベントリークを防止している。
- **null条件演算子の一貫した使用**: `GameManager.instance?.localizationManager` などのnullチェックが一貫しており、ゲーム初期化前のクラッシュを防止。

--- 
````

## v2 
````
---

## 🔍 分析プロセス（思考プロセス）

本Modは Cities: Skylines 2 のローカライゼーションシステムにリフレクションで深くアクセスし、Mod由来の翻訳キーを抽出・JSON出力し、またユーザ提供の翻訳JSONを読み込んで注入するシステムである。リスクの匂いを感じたのは、**(1)** リフレクションによる内部構造の再帰的スキャンが無制御に膨張しうる点、**(2)** 静的ミュータブル状態のスレッドセーフティ、**(3)** 外部JSONファイルの読み込みにおけるサイズ・パス検証の欠如、の3箇所である。

---

## 🚨 優先度: Critical / High (セキュリティ・バグ・パフォーマンスの重大欠陥)

### 1. `IsStandardCategory()` が呼び出しごとに `HashSet` をヒープ確保している

- **Why**: TranslationExtractor.cs の `IsStandardCategory()` は呼ばれるたびに50個超の要素を持つ `new HashSet<string>()` を生成している。このメソッドは `IdentifyModFromKeys()` 内のループから**全エントリキーごと**に呼ばれるため、数万エントリの抽出時に数万回のヒープアロケーション＋GCプレッシャーが発生する。ゲームのメインループ上で動作するため、フレーム落ちの直接的原因になりうる。
- **How**: `VanillaPrefixes` と同様に `private static readonly HashSet<string>` のクラスフィールドに昇格させる。

```csharp
private static readonly HashSet<string> StandardCategories = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
{
    "Options", "Tooltip", "Description", /* ... */
};

private static bool IsStandardCategory(string category)
{
    return StandardCategories.Contains(category);
}
```

### 2. `IsVanillaKey()` が `HashSet` の O(1) ルックアップを活かせていない（O(n) 線形走査）

- **Why**: TranslationExtractor.cs で `VanillaPrefixes` は `HashSet` だが、`StartsWith` で比較しているため **O(n)** の線形探索になっている。`VanillaPrefixes` に60要素以上あり、全キーに対してこのチェックが走るため、抽出時のボトルネックとなる。
- **How**: 設計意図は「プレフィックス一致」なので `HashSet` ではなく `string[]` か `List<string>` に変更して意図を明確にするか、ソート済み配列＋二分探索、または Trie ベースのプレフィックスマッチに変更する。現実的には要素数が100未満なので `string[]` + `Array.Exists` でも十分だが、データ構造とアルゴリズムの不一致は「HashSetだからO(1)」と誤解する保守者を生むため、型を合わせるべき。

```csharp
private static readonly string[] VanillaPrefixList = new[]
{
    "Assets.", "Camera.", /* ... */
};

private static bool IsVanillaKey(string key)
{
    for (int i = 0; i < VanillaPrefixList.Length; i++)
    {
        if (key.StartsWith(VanillaPrefixList[i], StringComparison.OrdinalIgnoreCase))
            return true;
    }
    return false;
}
```

### 3. 静的ミュータブルフラグのスレッドセーフティ欠如（競合状態）

- **Why**: Mod.cs の `SuppressLocaleCallback`, `LocaleChangePending`, `LastLocaleChangeTicks` は `static` かつ非 `volatile`/非アトミックである。`OnLocaleChanged()` はゲームエンジンのイベントコールバック（別スレッドの可能性あり）から呼ばれ、`TranslationLoaderSystem.OnUpdate()` はメインループスレッドから読み取る。`LastLocaleChangeTicks` と `LocaleChangePending` の書き込み順序がコンパイラ/CPU のリオーダリングで入れ替わると、`OnUpdate` が `Pending=true` を読んだ時に `Ticks` が古い値のまま → デバウンスが即座に発火し、連続イベントが抑制されないバグになる。
- **How**: 最低限 `volatile` を付与する。理想的には `Interlocked` 操作か、ロック不要の設計（`Interlocked.Exchange` でタイムスタンプだけ管理し、Pending フラグを廃止してタイムスタンプ差分のみで判定）にする。

```csharp
private static volatile long _lastLocaleChangeTicks = 0;
private static volatile bool _localeChangePending = false;
```

### 4. `ExtractEntriesFromObject` の再帰的リフレクション探索がオブジェクトグラフの循環参照で無限ループする可能性

- **Why**: TranslationExtractor.cs の再帰探索は `maxDepth` で深さは制限しているが、**訪問済みオブジェクトの追跡がない**。もし深さ3以内に同一オブジェクトへの参照が複数経路で存在する場合、同じオブジェクトの全フィールドを何度も走査する（指数的爆発）。ゲームエンジンの内部オブジェクトは循環参照を含む可能性が高い。`maxDepth=3` でもフィールド数が多いクラスでは組み合わせ爆発する。
- **How**: `HashSet<object>` (ReferenceEqualityComparer) で訪問済みオブジェクトを追跡する。

```csharp
private static Dictionary<string, string> ExtractEntriesFromObject(
    object obj, int maxDepth = 2, int currentDepth = 0, HashSet<object> visited = null)
{
    visited = visited ?? new HashSet<object>(ReferenceEqualityComparer.Instance);
    if (obj == null || currentDepth > maxDepth || !visited.Add(obj)) 
        return new Dictionary<string, string>();
    // ...
}
```

### 5. 翻訳JSONファイルの読み込みにファイルサイズ制限がない

- **Why**: TranslationLoader.cs の `File.ReadAllText(filePath)` はファイルサイズ無制限で全内容をメモリに読み込む。`SearchOption.AllDirectories` と相まって、巨大ファイルや大量ファイルが配置されるとメモリ枯渇（`OutOfMemoryException`）でゲームごとクラッシュしうる。Modユーザが誤って巨大ファイルを配置するシナリオは現実的。
- **How**: ファイルサイズの上限チェック（例: 50MB）を追加し、超過時はスキップ＋警告ログ。

```csharp
var fileInfo = new FileInfo(filePath);
if (fileInfo.Length > 50 * 1024 * 1024) // 50MB
{
    Mod.Log.Warn($"Skipping oversized file ({fileInfo.Length} bytes): {filePath}");
    return null;
}
```

---

## ⚠️ 優先度: Medium (アーキテクチャの整合性・保守性・設計の改善)

### 6. `ExtractionResult` クラスが TranslationExtractor.cs に同居している

- **Why**: TranslationExtractor.cs に `ExtractionResult` が定義されているが、`Models/` ディレクトリに TranslationData.cs が既にモデル層として存在している。アーキテクチャのレイヤリングルールと不整合である。
- **How**: `ExtractionResult` を `Models/ExtractionResult.cs` に移動する。

### 7. `LocalizationInjector._activeSources` が無限に蓄積する（メモリリーク）

- **Why**: LocalizationInjector.cs で `_activeSources.Add(source)` が呼ばれるが、`ClearTrackedSources()` は内部リストをクリアするだけで、**ゲーム側の `LocalizationManager` からソースを除去しない**。再読み込みのたびにソースが追加され続け、ゲームセッション中にメモリが累積する。コメントで「再注入で上書きする運用を想定」と書かれているが、ゲーム側が古いソースも保持し続ける場合、同一キーで複数ソースが競合し、意図しない翻訳が残る可能性がある。
- **How**: `LocalizationManager` にソース除去APIがあれば利用する。なければ、せめてリスト内のソースの辞書を空にして影響を最小化するか、注入前に古いソースの entries をクリアする仕組みを検討する。

### 8. 例外の「握りつぶし」が多数存在する

- **Why**: TranslationExtractor.cs 内に `catch { continue; }` や `catch { }` が複数箇所存在する（例: TranslationExtractor.cs, TranslationExtractor.cs, TranslationExtractor.cs）。リフレクションベースの処理で例外が多発しうることは理解できるが、デバッグモード時ですらログが出ないため、なぜ特定のModが抽出できないかの障害切り分けが不可能になる。
- **How**: `Mod.ModSetting?.EnableDebugLog == true` の場合のみ、例外メッセージをログ出力する。

```csharp
catch (Exception ex)
{
    if (Mod.ModSetting?.EnableDebugLog == true)
        Mod.Log.Warn($"[Extraction] Skipped source: {ex.Message}");
    continue;
}
```

### 9. `TranslationExtractorSystem` / `TranslationLoaderSystem` の `static` フラグが ECS の設計原則に反している

- **Why**: TranslationExtractorSystem.cs の `_extractionRequested` と TranslationLoaderSystem.cs の `_reloadRequested` が `static` であるため、システムの複数インスタンスが存在した場合やテスト時に状態が共有される。CS2のECSフレームワークでは通常シングルトンだが、static依存はテスタビリティを著しく損なう。
- **How**: 可能であればインスタンスフィールドに変更し、`RequestReload()` もインスタンスメソッドにする（`World.GetOrCreateSystemManaged<T>()` 経由でインスタンスを取得）。

### 10. `WriteModTranslationFile` で既存ファイルの読み込み失敗が翻訳データ消失につながる

- **Why**: TranslationExtractor.cs で既存の翻訳ファイル読み込みが `catch` で握りつぶされ、空の `existingTranslations` のまま新規ファイルが上書きされる。ユーザが労力をかけて翻訳した内容がJSON破損等で一発消失するリスクがある。
- **How**: 既存ファイルの読み込みに失敗した場合、**上書きを中止**してエラーを報告するか、バックアップファイルを作成してから上書きする。

```csharp
catch (Exception ex)
{
    Mod.Log.Error($"Existing translation file is corrupted, skipping overwrite: {checkPath}");
    // バックアップ作成
    File.Copy(checkPath, checkPath + ".bak", overwrite: true);
}
```

---

## 💡 優先度: Low (よりモダンな書き方・軽微な最適化)

- **`IdentifyModFromKeys` 内の LINQ `OrderByDescending(...).First()`** (TranslationExtractor.cs): 最大値を1つ取るだけなので `candidates.Aggregate((a, b) => a.Value > b.Value ? a : b)` または `.MaxBy()` (C# 10+でなければ手動) で O(n) に最適化可能。
- **`VanillaPrefixes` の `"Options.SECTION[General]"` 等の完全一致パターン**: `StartsWith` で判定しているが、これらは実質「完全一致」であり、他のプレフィックスとは質的に異なる。完全一致用とプレフィックス用にコレクションを分離すると意図が明確になる。
- **`Mod.ModSetting?.EnableDebugLog == true` パターンの繰り返し**: 共通のヘルパーメソッド `LogDebug(string message)` を導入し、ガード条件の重複を排除すると可読性が向上する。
- **`TranslationLoader.BuildDictionary`** (TranslationLoader.cs): `dictionary.ContainsKey` → `TryGetValue` のパターンで二重ルックアップを回避できる（微小な改善）。
- **`NormalizeModName`** (TranslationExtractor.cs): `Replace` の連鎖は毎回新しい文字列をアロケートする。`StringBuilder` または `Span<char>` 化で最適化可能（ただし現状の呼び出し頻度では実質無視可能）。

---

## 🛡️ 良かった点 (Good Practices)

- **デバウンスパターンの実装**: ロケール変更イベントを即座に処理せず、`DebounceSeconds` で遅延処理するアーキテクチャは、翻訳注入が `onActiveDictionaryChanged` を再帰的にトリガーする問題を正しく防いでいる。
- **Phase 1 / Phase 2 フォールバック戦略**: ソースベース抽出が失敗した場合に辞書ベース抽出にフォールバックする多層設計は、ゲームのバージョンアップで内部構造が変わった場合の耐障害性を担保している。
- **`SuppressLocaleCallback` による再帰呼び出し抑制**: 翻訳注入時にコールバックを抑制する設計は正しく、`try/finally` で確実に復元している点も堅実。
- **既存翻訳のマージロジック**: 抽出時に既存の翻訳ファイルを読み込み、ユーザの翻訳作業を保持する設計はUX上非常に優れている。
- **`SanitizeModId` によるファイル名サニタイズ**: `Path.GetInvalidFileNameChars()` を使用してMod IDをファイル名安全な形に変換しており、パストラバーサルの基本的な対策ができている。
- **ロケール優先順位の明確な設計**: `GetLocalePriority` で en-US → en-* → その他の優先順位を明確に定義しており、翻訳元言語として英語を確実に使用する設計意図が反映されている。
````